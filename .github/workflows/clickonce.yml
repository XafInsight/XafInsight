name: Build & Publish VSTO (main → GitHub Pages)

permissions:
  contents: write  # push naar gh-pages + releases

on:
  push:
    branches: [ main ]
  workflow_dispatch: {}

jobs:
  build-and-deploy:
    runs-on: windows-latest

    steps:
      - uses: actions/checkout@v4

      - name: Setup MSBuild
        uses: microsoft/setup-msbuild@v2

      - name: Restore NuGet
        run: nuget restore xafplugin.sln

      # 1) Decodeer PFX, importeer in CurrentUser\My, expose THUMBPRINT
      - name: Restore & import signing certificate
        id: cert
        shell: pwsh
        run: |
          if (-not "${{ secrets.CODESIGN_PFX_B64 }}") { throw "Missing secret CODESIGN_PFX_B64" }
          if (-not "${{ secrets.CODESIGN_PFX_PASSWORD }}") { throw "Missing secret CODESIGN_PFX_PASSWORD" }

          $pfxPath = Join-Path $env:RUNNER_TEMP "codesign.pfx"
          [IO.File]::WriteAllBytes($pfxPath, [Convert]::FromBase64String("${{ secrets.CODESIGN_PFX_B64 }}"))

          certutil -p "${{ secrets.CODESIGN_PFX_PASSWORD }}" -dump "$pfxPath" | Out-Null

          $sec = ConvertTo-SecureString "${{ secrets.CODESIGN_PFX_PASSWORD }}" -AsPlainText -Force
          $cert = Import-PfxCertificate -FilePath "$pfxPath" -CertStoreLocation Cert:\CurrentUser\My -Password $sec
          if (-not $cert.HasPrivateKey) { throw "Imported cert has no private key" }

          "thumb=$($cert.Thumbprint)" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

      # 2) ClickOnce Publish (gesigned via THUMBPRINT) + forceer outputmap
      - name: ClickOnce Publish (main, signed via thumbprint)
        shell: pwsh
        run: >
          msbuild "xafplugin/xafplugin.csproj"
          /t:Publish /p:Configuration=Release
          /p:AutoIncrementApplicationRevision=true
          /p:SignManifests=true
          /p:ManifestCertificateThumbprint=${{ steps.cert.outputs.thumb }}
          /p:PublishDir="$((Resolve-Path .).Path)\xafplugin\publish\"
          /p:ManifestTimestampUrl=http://timestamp.digicert.com

      # (Nieuw) Toon publish-output direct na publish voor debug
      - name: List publish output (after publish)
        shell: pwsh
        run: |
          Write-Host "Workspace: $((Resolve-Path .).Path)"
          if (Test-Path "xafplugin\publish") {
            Write-Host "Publish folder content:"
            Get-ChildItem -Recurse -Force "xafplugin\publish" | ForEach-Object { Write-Host $_.FullName }
          } else {
            Write-Host "Publish folder not found."
            Write-Host "Fallback check (bin\Release\app.publish):"
            if (Test-Path "xafplugin\bin\Release\app.publish") {
              Get-ChildItem -Recurse -Force "xafplugin\bin\Release\app.publish" | ForEach-Object { Write-Host $_.FullName }
            }
          }

      # 2b) Versie uit VSTO-manifest halen (Excel add-in: geen .application)
      - name: Extract ClickOnce version from VSTO
        id: ver
        shell: pwsh
        run: |
          function Get-ClickOnceVersion {
            param([string]$Path)
            if (-not (Test-Path $Path)) { return $null }
            [xml]$xml = Get-Content -LiteralPath $Path

            $nsm = New-Object System.Xml.XmlNamespaceManager($xml.NameTable)
            $nsm.AddNamespace("asmv1","urn:schemas-microsoft-com:asm.v1")
            $nsm.AddNamespace("asmv2","urn:schemas-microsoft-com:asm.v2")
            $nsm.AddNamespace("co","urn:schemas-microsoft-com:clickonce.v2")
            $nsm.AddNamespace("vsto","urn:schemas-microsoft-com:vsto.v4")

            # 1) assemblyIdentity/@version (meest stabiel)
            $node = $xml.SelectSingleNode("//asmv1:assemblyIdentity", $nsm)
            if ($node -and $node.version) { return $node.version }

            # 2) clickonce deployment/identity/@version (soms aanwezig)
            $node = $xml.SelectSingleNode("//co:deployment/co:identity", $nsm)
            if ($node -and $node.version) { return $node.version }

            # 3) asm.v2 deployment/assemblyIdentity
            $node = $xml.SelectSingleNode("//asmv2:deployment/asmv1:assemblyIdentity", $nsm)
            if ($node -and $node.version) { return $node.version }

            return $null
          }

          $pub = "xafplugin\publish"
          $fallback = "xafplugin\bin\Release\app.publish"

          # Zoek alleen VSTO recursief (Excel VSTO add-in)
          $vstoFile = Get-ChildItem $pub -Recurse -Filter *.vsto -ErrorAction SilentlyContinue | Select-Object -First 1
          if (-not $vstoFile -and (Test-Path $fallback)) {
            $vstoFile = Get-ChildItem $fallback -Recurse -Filter *.vsto -ErrorAction SilentlyContinue | Select-Object -First 1
          }

          if (-not $vstoFile) {
            Write-Host "Kon geen .vsto vinden in $pub of fallback $fallback."
            if (Test-Path $pub) {
              Get-ChildItem -Recurse -Force $pub | ForEach-Object { Write-Host $_.FullName }
            }
            Write-Error "VSTO manifest (.vsto) niet gevonden."
            exit 1
          }

          $version = Get-ClickOnceVersion -Path $vstoFile.FullName

          if (-not $version) {
            Write-Host "VSTO manifest: $($vstoFile.FullName)"
            Write-Error "Kon ClickOnce versie niet vinden in VSTO manifest (namespaces/locatie)."
            exit 1
          }

          "CLICKONCE_VERSION=$version" | Out-File -FilePath $env:GITHUB_ENV -Append
          "version=$version"          | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          Write-Host "ClickOnce version: $version"

      # 2c) Guard: faal als versie al bestaat (tag of al op gh-pages)
      - name: Guard - fail if version already released
        shell: pwsh
        run: |
          $ver = "${{ steps.ver.outputs.version }}"
          if (-not $ver) { Write-Error "No version from manifest"; exit 1 }

          # 1) Tag check
          git fetch --tags origin | Out-Null
          $tagExists = git tag -l "v$ver"
          if ($tagExists) {
            Write-Error "Tag v$ver already exists. Aborting to avoid duplicate release."
            exit 1
          }

          # 2) gh-pages check — zoek naar een Application Files pad dat deze versie bevat
          try {
            git fetch origin gh-pages --depth=1 | Out-Null
            $paths = git ls-tree -r --name-only origin/gh-pages
            if ($paths) {
              $re = 'clickonce[\\/]+Application Files[\\/].*' + [regex]::Escape($ver)
              $match = $paths | Where-Object { $_ -match $re }
              if ($match) {
                Write-Error "gh-pages already contains artifacts for version $ver. Aborting."
                exit 1
              }
            }
          } catch {
            Write-Host "gh-pages does not exist yet (first deploy) — continuing."
          }

          Write-Host "Version $ver is new — continuing."

      # 3) Zet volledige publish-output naar /clickonce/ op gh-pages
      - name: Prepare site folder for Pages
        shell: pwsh
        run: |
          if (Test-Path site) { Remove-Item -Recurse -Force site }
          New-Item -ItemType Directory -Force "site/clickonce" | Out-Null
          Copy-Item "xafplugin\publish\*" "site\clickonce" -Recurse -Force

      # 3a) Forceer binaire bytes (geen CRLF/LF conversie) voor alles onder /clickonce/
      - name: Add .gitattributes to preserve file bytes
        shell: pwsh
        run: |
          $lines = @(
            '# Force binary handling: no CRLF/LF conversion for ClickOnce payload'
            '/clickonce/** -text'
          )
          Set-Content -Path "site/.gitattributes" -Value $lines -Encoding ASCII

      # 3b) Zet .nojekyll zodat GitHub Pages niets probeert te verwerken
      - name: Disable Jekyll on GitHub Pages
        shell: pwsh
        run: New-Item -ItemType File -Path "site/.nojekyll" -Force | Out-Null

      # 3c) Kopieer publiek certificaat naar de ClickOnce folder
      - name: Copy public certificate to clickonce folder
        shell: pwsh
        run: |
          $certFile = "xafinsight_codesign.cer"
          if (Test-Path $certFile) {
            Copy-Item $certFile "site/clickonce/" -Force
            Write-Host "Copied $certFile to site/clickonce/"
          } else {
            Write-Host "Warning: $certFile not found in repo root."
          }

      # 3d) Genereer index.html en toon versie (zonder .application)
      - name: Generate index.html
        shell: pwsh
        run: |
          $dest = "site\clickonce"
          $ver  = "${{ steps.ver.outputs.version }}"
          New-Item -ItemType Directory -Force $dest | Out-Null

          $links = @()
          if (Test-Path "$dest\setup.exe")      { $links += '    <li><a href="setup.exe">setup.exe</a> (bootstrapper)</li>' }
          # VSTO manifest kan willekeurige naam hebben — zoek recursief en link de eerste
          $vsto = Get-ChildItem $dest -Recurse -Filter *.vsto -ErrorAction SilentlyContinue | Select-Object -First 1
          if ($vsto) {
            $rel = $vsto.FullName.Substring((Resolve-Path $dest).Path.Length + 1) -replace '\\','/'
            $links += "    <li><a href=""$rel"">$(Split-Path -Leaf $rel)</a> (add-in manifest)</li>"
          }
          if (Test-Path "$dest\xafinsight_codesign.cer") { $links += '    <li><a href="xafinsight_codesign.cer">xafinsight_codesign.cer</a> (signing certificate)</li>' }

          $htmlLines = @(
            '<!doctype html>',
            '<html lang="en">',
            '<head>',
            '  <meta charset="utf-8" />',
            '  <meta http-equiv="x-ua-compatible" content="ie=edge" />',
            '  <meta name="viewport" content="width=device-width, initial-scale=1" />',
            '  <title>XafInsight ClickOnce</title>',
            '</head>',
            '<body>',
            '  <h1>XafInsight ClickOnce deployment</h1>',
            "  <p><strong>Version:</strong> $ver</p>",
            '  <ul>'
          ) + $links + @(
            '  </ul>',
            '</body>',
            '</html>'
          )

          $htmlLines | Set-Content -Path "$dest\index.html" -Encoding UTF8

      - name: Deploy to gh-pages (keep existing files)
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: site
          publish_branch: gh-pages
          keep_files: true

      # 4) Verzamelen van release-assets (recursief zoeken, geen .application)
      - name: Collect release assets
        shell: pwsh
        run: |
          if (Test-Path out) { Remove-Item -Recurse -Force out }
          New-Item -ItemType Directory -Force out | Out-Null

          $src = "xafplugin\publish"

          $vsto  = Get-ChildItem $src -Recurse -Filter *.vsto -ErrorAction SilentlyContinue | Select-Object -First 1
          $setup = Get-ChildItem $src -Recurse -Filter setup.exe -ErrorAction SilentlyContinue | Select-Object -First 1

          if ($vsto)  { Copy-Item $vsto.FullName  "out\xafplugin.vsto" -Force }
          if ($setup) { Copy-Item $setup.FullName "out\setup.exe"      -Force }

          # Laat ook de map Application Files als zip achter (handig voor debug/archief)
          $appFiles = Join-Path $src "Application Files"
          if (Test-Path $appFiles) {
            Add-Type -A System.IO.Compression.FileSystem
            $zip = Join-Path (Resolve-Path out) "application-files.zip"
            if (Test-Path $zip) { Remove-Item $zip -Force }
            [System.IO.Compression.ZipFile]::CreateFromDirectory($appFiles, $zip)
          }

      # 4a) Hernoem assets met versie
      - name: Rename assets with version
        shell: pwsh
        run: |
          $v = "${{ steps.ver.outputs.version }}"
          if (Test-Path "out\xafplugin.vsto") { Rename-Item "out\xafplugin.vsto" "out\xafplugin-$v.vsto" }
          if (Test-Path "out\setup.exe")      { Rename-Item "out\setup.exe"      "out\setup-$v.exe" }

      # 4b) Korte SHA voor in de release-naam
      - name: Compute short SHA
        shell: pwsh
        run: |
          $short = "${{ github.sha }}".Substring(0,7)
          "SHORT_SHA=$short" | Out-File -FilePath $env:GITHUB_ENV -Append

      # 4c) Schrijf de ClickOnce versie terug in xafplugin.csproj zodat baseline meeloopt
      - name: Sync ApplicationVersion in csproj and push [skip ci]
        shell: pwsh
        run: |
          $csproj = "xafplugin\xafplugin.csproj"
          $ver = "${{ steps.ver.outputs.version }}"

          if (-not (Test-Path $csproj)) { throw "csproj not found: $csproj" }

          [xml]$xml = Get-Content $csproj
          $nsm = New-Object System.Xml.XmlNamespaceManager($xml.NameTable)
          $nsm.AddNamespace("msb","http://schemas.microsoft.com/developer/msbuild/2003")

          $node = $xml.SelectSingleNode("//msb:Project/msb:PropertyGroup/msb:ApplicationVersion", $nsm)
          if (-not $node) {
            $pg = $xml.SelectSingleNode("//msb:Project/msb:PropertyGroup[1]", $nsm)
            if (-not $pg) { throw "No PropertyGroup in csproj" }
            $node = $xml.CreateElement("ApplicationVersion", "http://schemas.microsoft.com/developer/msbuild/2003")
            $pg.AppendChild($node) | Out-Null
          }

          $old = $node.InnerText
          $node.InnerText = $ver
          $xml.Save($csproj)

          if ($old -ne $ver) {
            git config user.email "ci@github.actions"
            git config user.name  "GitHub Actions"
            git add $csproj
            git commit -m "chore: sync ApplicationVersion to $ver [skip ci]" | Out-Null
            git push origin HEAD:main
            Write-Host "Updated ApplicationVersion from '$old' to '$ver' and pushed [skip ci]."
          } else {
            Write-Host "ApplicationVersion already '$ver'; no commit."
          }

      # 5) Maak/Update een Release voor deze build (tag = v<ClickOnceVersion>)
      - name: Create GitHub Release for build
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ steps.ver.outputs.version }}
          target_commitish: ${{ github.sha }}
          name: "XafInsight ${{ steps.ver.outputs.version }} (${{ env.SHORT_SHA }})"
          draft: false
          prerelease: false
          files: |
            out/xafplugin-${{ steps.ver.outputs.version }}.vsto
            out/setup-${{ steps.ver.outputs.version }}.exe
            out/application-files.zip
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
